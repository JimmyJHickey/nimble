% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Laplace.R
\name{Laplace_BASE}
\alias{Laplace_BASE}
\alias{nimOneLaplace1D}
\alias{nimOneLaplace}
\alias{buildLaplace}
\alias{summaryLaplace}
\alias{laplace}
\alias{Laplace}
\title{Laplace approximation}
\usage{
Laplace_BASE()

nimOneLaplace1D(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  optimControl,
  optimMethod,
  optimStart
)

nimOneLaplace(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  optimControl,
  optimMethod,
  optimStart
)

buildLaplace(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  control = list()
)

summaryLaplace(
  cLaplace,
  scale = "original",
  calcRandomEffectsStdError = FALSE,
  returnJointCovariance = FALSE
)
}
\arguments{
\item{model}{an uncompiled NIMBLE model object.}

\item{paramNodes}{a character vector of names of parameter nodes in the model; defaults to top-level stochastic nodes.}

\item{randomEffectsNodes}{a character vector of names of latent nodes to integrate out using the Laplace approximation; defaults to latent nodes that depend on \code{paramNodes}.}

\item{calcNodes}{a character vector of names of nodes for calculating the log-likelihood value; defaults to \code{model$geteDependencies(randomEffectsNodes)}. 
There may be deterministic nodes between \code{paramNodes} and \code{randomEffectsNodes}. These will be included in calculations automatically.}

\item{optimControl}{a list of control parameters for the inner optimization of Laplace approximation using \code{optim}. Needed only for \code{nimOneLaplace} and \code{nimOneLaplace1D}. See 'Details' of \code{\link{optim}} for further information.}

\item{optimMethod}{optimization method to be used in \code{optim} for the inner optimization. Needed only for \code{nimOneLaplace} and \code{nimOneLaplace1D}. See 'Details' of \code{\link{optim}}.
Currently \code{nimOptim} supports: "\code{Nelder-Mead}", "\code{BFGS}", "\code{CG}", "\code{L-BFGS-B}". By default, method "\code{CG}" is used for \code{nimOneLaplace1D} and "\code{BFGS}" for \code{nimOneLaplace}.}

\item{optimStart}{choice of start values for the inner optimization. This could be \code{"last"}, \code{"last.best"}, or a vector of user provided values. \code{"last"} means the latest random effects values left in the model will be used. 
\code{"last.best"} means the latest random effects values corresponding to currently the largest Laplace likelihood will be used. By default, the initial random effects values will be used for inner optimization.}

\item{control}{a named list (for \code{buildLaplace} only) that controls the behavior of the Laplace approximation. See \code{control} section below.}

\item{cLaplace}{a compiled Laplace algorithm.}

\item{scale}{specifies the scale of the summarized Laplace results: 'original' (default) or 'transform'.}

\item{calcRandomEffectsStdError}{if the standard errors for random effects estimates are calculated; defaults to FALSE.}

\item{returnJointCovariance}{if the joint covariance matrix of the estimators of random effects and parameters is returned; defaults to FALSE.}
}
\description{
Builds a Laplace approximation algorithm for a given NIMBLE model.
}
\section{\code{control} list}{


\code{buildLaplace} accepts the following control list elements:
\itemize{
  \item \code{split}. If TRUE (default), \code{randomEffectsNodes} will be split into conditionally independent sets if possible.
        If FALSE, \code{randomEffectsNodes} will be handled as a multivariate block.
        If a vector, \code{randomEffectsNodes} will be split by \code{split}(\code{randomEffectsNodes}, \code{control$split}).
        The last option allows arbitrary control over how \code{randomEffectsNodes} are blocked.
  \item \code{warn}. If TRUE (default), a warning is issued if \code{randomEffectsNodes}/\code{calcNodes} is provided and has extra or missing elements.
  \item \code{innerOptimControl}. See \code{optimControl}. 
  \item \code{innerOptimMethod}. See \code{optimMethod}.
  \item \code{innerOptimStart}. see \code{optimStart}.
  \item \code{outOptimControl}. A list of control parameters for maximizing the Laplace log-likelihood using \code{optim}. 
        See 'Details' of \code{\link{optim}} for further information.
}
}

\section{\code{Laplace_BASE}}{


Laplace base class, upon which specific Laplace algorithm classes are based by including \code{contains = Laplace_BASE}. This declares a list of nimbleFunctions for a single Laplace approximation.
}

\section{\code{nimOneLaplace1D}}{


This function is suitable for constructing a single Laplace approximation when \code{randomEffectsNodes} contains only one scalar node.
To use this function, one has to accurately provide inputs for all the arguments. 

This function generates an object that comprises a set of methods (functions), each accomplishing one piece of many calculations to obtain the Laplace approximation and its gradient w.r.t. model parameters. 
Among these methods, six are most useful to a user:
\itemize{
  \item \code{Laplace1(p)}. Laplace approximation evaluated at the parameter value \code{p}. This function uses single taping for gradient and Hessian calculations and separate components.
  \item \code{Laplace2(p)}. Laplace approximation evaluated at the parameter value \code{p}. This function uses double taping for gradient and Hessian calculations and separate components.
  \item \code{Laplace3(p)}. Laplace approximation evaluated at the parameter value \code{p}. This function uses double taping for gradient and Hessian calculations and packs everything together.
  \item \code{gr_Laplace1(p)}. Gradient of \code{Laplace1} w.r.t. parameters evaluated at the parameter value \code{p}.
  \item \code{gr_Laplace2(p)}. Gradient of \code{Laplace2} w.r.t. parameters evaluated at the parameter value \code{p}.
  \item \code{gr_Laplace3(p)}. Gradient of \code{Laplace3} w.r.t. parameters evaluated at the parameter value \code{p}.
}
}

\section{\code{nimOneLaplace}}{


This function is suitable for constructing a single Laplace approximation when \code{randomEffectsNodes} contains more than one scalar node.
To use this function, one has to accurately provide inputs for all the arguments. 

The methods generated by this function are the same as \code{nimOneLaplace1D}.
}

\section{\code{buildLaplace}}{


The main function for constructing the Laplace approximation for a given model. One only needs to provide a NIMBLE model object and then the function
will determine inputs for \code{paramNodes}, \code{randomEffectsNodes}, and \code{calcNodes} and then construct the Laplace algorithm. 
Default settings are given inside the function and can be changed for all control parameters inside the \code{control} argument. 

The Laplace algorithm object contains a list of functions:
\itemize{
  \item \code{set_method(method)}. Set method ID for calculating the Laplace approximation and gradient: 1 (\code{Laplace1}), 2 (\code{Laplace2}, default method), or 3 (\code{Laplace3}).
  \item \code{get_method()}. Return the method ID currently used in the algorithm. 
  \item \code{one_time_fixes()}. Fix the dimensionality issue if there is only one parameter in the model. This function is called where necessary and users do not need to run this.  
  \item \code{Laplace(p)}. Laplace approximation at parameter value \code{p}.
  \item \code{gr_Laplace(p)}. Gradient of the Laplace approximation at parameter value \code{p}.
  \item \code{p_transformed_Laplace(pTransform)}. Laplace approximation at transformed parameter value \code{pTransform}. 
        To make maximizing the Laplace likelihood unconstrained, an automated transformation via \code{\link{parameterTransform}} is performed on any parameters with value constraints.  
  \item \code{p_transformed_gr_Laplace(pTransform)}. Gradient of the Laplace approximation (with parameter transformation) w.r.t. transformed parameters, evaluated at transformed parameter value \code{pTransform}.
  \item \code{LaplaceMLE(pStart, method, hessian)}. Run maximum likelihood estimation and return results on the transformed scale if any. 
        Arguments include \code{pStart}: start value on the original scale; default to parameter values in the model, \code{method}: optimization method used in \code{optim}; default \code{BFGS}, and \code{hessian}: whether calculating the Hessian matrix or not; default to \code{TRUE}.
  \item \code{pInverseTransform(pTransform)}. Back transform the transformed parameter value \code{pTransform} to original scale.
  \item \code{derivspInverseTransform(pTransform, order)}. Derivative of the inverse transformation w.r.t. transformed parameters at \code{pTransform}. Derivative order is given by \code{order}.
  \item \code{reInverseTransform(reTrans)}. Back transform the transformed random effects value \code{reTrans} to original scale.
  \item \code{derivsreInverseTransform(reTrans, order)}. Derivative of the inverse transformation w.r.t. transformed random effects at \code{reTrans}. Derivative order is given by \code{order}.
  \item \code{optimRandomEffects(pTransform)} Calculate the optimized random effects given transformed parameter value \code{pTransform}.
  \item \code{inverseNegHess(p, reTransform)} Calculate the inverse of the negative Hessian matrix of the joint log-likelihood w.r.t. transformed random effects, evaluated at parameter value \code{p} and transformed random effects \code{reTransform}.
  \item \code{summary(LaplaceMLEOutput)}. Summarize the maximum likelihood estimation results, given object \code{LaplaceMLEOutput} that is returned by \code{LaplaceMLE}. This function generates a list of original parameter names, estimates, and standard errors.  
}
}

\section{\code{summaryLaplace}}{


This function summarizes Laplace maximum likelihood estimation results given a compiled Laplace algorithm. 
If \code{LaplaceMLE()} is called before, \code{summaryLaplace} will calculate standard errors and covariance matrix (if required) and do scale transformations if necessary.
Otherwise, \code{LaplaceMLE()} will be called internally to do maximum likelihood estimation first. 
If transformations are used for optimization, standard errors and covariance matrix on original scale are obtained by the delta method. 
It returns a named list (\code{params}, \code{random}, and \code{vcov}) and more specifically it returns the following:
\itemize{
  \item \code{params}: estimates and standard errors of parameters on a specified scale, i.e. original or transformed.
  \item \code{random}: estimates of random effects and if required their standard errors.
  \item \code{vcov}: if required, joint variance-covariance matrix of the estimators of random effects and parameters; otherwise it is null. 
}
}

\examples{
pumpCode <- nimbleCode({ 
  for (i in 1:N){
    theta[i] ~ dgamma(alpha, beta)
    lambda[i] <- theta[i] * t[i]
    x[i] ~ dpois(lambda[i])
  }
  alpha ~ dexp(1.0)
  beta ~ dgamma(0.1, 1.0)
})
pumpConsts <- list(N = 10, t = c(94.3, 15.7, 62.9, 126, 5.24, 31.4, 1.05, 1.05, 2.1, 10.5))
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))
pumpInits <- list(alpha = 0.1, beta = 0.1, theta = rep(0.1, pumpConsts$N))
pump <- nimbleModel(code = pumpCode, name = "pump", constants = pumpConsts, 
                    data = pumpData, inits = pumpInits, buildDerivs = TRUE)
                    
# Build Laplace approximation
pumpLaplace <- buildLaplace(pump)

\dontrun{
# Compile the model
Cpump <- compileNimble(pump)
CpumpLaplace <- compileNimble(pumpLaplace, project = pump)
# Calculate MLEs on transformed scale
MLEres <- CpumpLaplace$LaplaceMLE(c(0.1, 0.1))
# Calculate estimates and standard errors for parameters and random effects on original scale
summ <- summaryLaplace(CpumpLaplace, calcRandomEffectsStdError = TRUE)
}

}
\author{
Wei Zhang, Perry de Valpine
}
