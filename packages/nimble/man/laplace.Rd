% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Laplace.R
\name{Laplace_BASE}
\alias{Laplace_BASE}
\alias{nimOneLaplace1D}
\alias{nimOneLaplace}
\alias{buildLaplace}
\alias{laplace}
\alias{Laplace}
\title{Laplace approximation}
\usage{
Laplace_BASE()

nimOneLaplace1D(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  optimControl,
  optimMethod,
  optimStart
)

nimOneLaplace(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  optimControl,
  optimMethod,
  optimStart
)

buildLaplace(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  control = list()
)
}
\arguments{
\item{model}{an uncompiled NIMBLE model object.}

\item{paramNodes}{a character vector of names of parameter nodes in the model; defaults to top-level stochastic nodes.}

\item{randomEffectsNodes}{a character vector of names of latent nodes to integrate out using the Laplace approximation; defaults to latent nodes that depend on \code{paramNodes}.}

\item{calcNodes}{a character vector of names of nodes for calculating the log-likelihood value; defaults to \code{model$geteDependencies(randomEffectsNodes)}. There may be deterministic nodes between \code{paramNodes} and \code{randomEffectsNodes}. These will be included in calculations automatically.}

\item{optimControl}{a list of control parameters for the inner optimization of Laplace approximation using \code{optim}. Needed only for \code{nimOneLaplace} and \code{nimOneLaplace1D}. See 'Details' of \code{\link{optim}} for further information.}

\item{optimMethod}{optimization method to be used in \code{optim} for the inner optimization. Needed only for \code{nimOneLaplace} and \code{nimOneLaplace1D}. See 'Details' of \code{\link{optim}}.Currently \code{nimOptim} supports: "\code{Nelder-Mead}", "\code{BFGS}", "\code{CG}", "\code{L-BFGS-B}". By default, method "\code{CG}" is used for \code{nimOneLaplace1D} and "\code{BFGS}" for \code{nimOneLaplace}.}

\item{optimStart}{choice of start values for the inner optimization. This could be \code{"last"}, \code{"last.best"}, or a vector of user provided values. \code{"last"} means the latest random effects values left in the model will be used. \code{"last.best"} means the latest random effects values corresponding to currently the largest Laplace likelihood will be used. By default, the initial random effects values will be used for all inner optimizations.}

\item{control}{a named list (for \code{buildLaplace} only) that controls the behavior of the Laplace approximation. See \code{control} section below.}
}
\description{
Builds a Laplace approximation algorithm for a given NIMBLE model.
}
\section{\code{control} list}{


\code{buildLaplace} accepts the following control list elements:
\itemize{
  \item \code{split}. If TRUE (default), \code{randomEffectsNodes} will be split into conditionally independent sets if possible.
        If FALSE, \code{randomEffectsNodes} will be handled as a multivariate block.
        If a vector, \code{randomEffectsNodes} will be split by \code{split}(\code{randomEffectsNodes}, \code{control$split}).
        The last option allows arbitrary control over how \code{randomEffectsNodes} are blocked.
  \item \code{warn}. If TRUE (default), a warning is issued if \code{randomEffectsNodes}/\code{calcNodes} is provided and has extra or missing elements.
  \item \code{innerOptimControl}. See \code{optimControl}. 
  \item \code{innerOptimMethod}. See \code{optimMethod}.
  \item \code{innerOptimStart}. see \code{optimStart}.
  \item \code{outOptimControl}. A list of control parameters for maximizing the Laplace log-likelihood using \code{optim}. 
        See 'Details' of \code{\link{optim}} for further information.
}
}

\section{\code{Laplace_BASE}}{


Laplace base class, upon which specific Laplace algorithm classes are based by including \code{contains = Laplace_BASE}. This declares a list of nimbleFunctions for a single Laplace approximation.
}

\section{\code{nimOneLaplace1D}}{


This function is suitable for constructing a single Laplace approximation when \code{randomEffectsNodes} contains only one scalar node.
To use this function, one has to accurately provide inputs for all the arguments. 

This function generates an object that comprises a set of methods (functions), each accomplishing one piece of many calculations to obtain the Laplace approximation and its gradient w.r.t. model parameters. 
Among these methods, six are most useful to a user:
\itemize{
  \item \code{Laplace1(p)}. Laplace approximation evaluated at the parameter value \code{p}. This function uses single taping for gradient and Hessian calculations and separate components.
  \item \code{Laplace2(p)}. Laplace approximation evaluated at the parameter value \code{p}. This function uses double taping for gradient and Hessian calculations and separate components.
  \item \code{Laplace3(p)}. Laplace approximation evaluated at the parameter value \code{p}. This function uses double taping for gradient and Hessian calculations and packs everything together.
  \item \code{gr_Laplace1(p)}. Gradient of \code{Laplace1} w.r.t. parameters evaluated at the parameter value \code{p}.
  \item \code{gr_Laplace2(p)}. Gradient of \code{Laplace2} w.r.t. parameters evaluated at the parameter value \code{p}.
  \item \code{gr_Laplace3(p)}. Gradient of \code{Laplace3} w.r.t. parameters evaluated at the parameter value \code{p}.
}
}

\section{\code{nimOneLaplace}}{


This function is suitable for constructing a single Laplace approximation when \code{randomEffectsNodes} contains more than one scalar node.
To use this function, one has to accurately provide inputs for all the arguments. 

The methods generated by this function are the same as \code{nimOneLaplace1D}.
}

\section{\code{buildLaplace}}{


The main function for constructing the Laplace approximation for a given model. One only needs to provide a NIMBLE model object and then the function
will determine inputs for \code{paramNodes}, \code{randomEffectsNodes}, and \code{calcNodes} and then construct the Laplace algorithm. 
Default settings are given inside the function and can be changed for all control parameters inside the \code{control} argument. 

The Laplace algorithm object contains a list of functions:
\itemize{
  \item \code{set_method(method)}. Set method ID for calculating the Laplace approximation and gradient: 1 (\code{Laplace1}), 2 (\code{Laplace2}, default method), or 3 (\code{Laplace3}).
  \item \code{get_method()}. Return the method ID currently used in the algorithm. 
  \item \code{one_time_fixes()}. Fix the dimensionality issue if there is only one parameter in the model. This function is called where necessary and users do not need to run this.  
  \item \code{Laplace(p)}. Laplace approximation at parameter value \code{p}.
  \item \code{gr_Laplace(p)}. Gradient of the Laplace approximation at parameter value \code{p}.
  \item \code{p_transformed_Laplace(pTransform)}. Laplace approximation at transformed parameter value \code{pTransform}. 
        To make maximizing the Laplace likelihood unconstrained, an automated transformation via \code{\link{parameterTransform}} is performed on any parameters with value constraints.  
  \item \code{p_transformed_gr_Laplace(pTransform)}. Gradient of the Laplace approximation (with parameter transformation) w.r.t. transformed parameters, evaluated at transformed parameter value \code{pTransform}.
  \item \code{LaplaceMLE(pStart, method, hessian)}. Run maximum likelihood estimation and return results on the transformed scale if any. 
        Arguments include \code{pStart}: start value on the original scale; default to parameter values in the model, \code{method}: optimization method used in \code{optim}; default \code{BFGS}, and \code{hessian}: whether calculating the Hessian matrix or not; default to \code{TRUE}.
  \item \code{inverseTransform(pTransform)}. Back transform the transformed parameter value \code{pTransform} to original scale.
  \item \code{derivsInverseTransform(pTransform, order)}. Derivative of the inverse transformation w.r.t. transformed parameters at \code{pTransform}. Derivative order is given by \code{order}.
  \item \code{summary(res)}. Summarize the maximum likelihood estimation results, given object \code{res} that is returned by \code{LaplaceMLE}. This function generates a list of original parameter names, estimates, and standard errors.  
}
}

\examples{
pumpCode <- nimbleCode({ 
  for (i in 1:N){
    theta[i] ~ dgamma(alpha, beta)
    lambda[i] <- theta[i] * t[i]
    x[i] ~ dpois(lambda[i])
  }
  alpha ~ dexp(1.0)
  beta ~ dgamma(0.1, 1.0)
})
pumpConsts <- list(N = 10, t = c(94.3, 15.7, 62.9, 126, 5.24, 31.4, 1.05, 1.05, 2.1, 10.5))
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))
pumpInits <- list(alpha = 0.1, beta = 0.1, theta = rep(0.1, pumpConsts$N))
pump <- nimbleModel(code = pumpCode, name = "pump", constants = pumpConsts, 
                    data = pumpData, inits = pumpInits, buildDerivs = TRUE)
# Build Laplace approximation
pumpLaplace <- buildLaplace(pump)

\dontrun{
# Compile the model
Cpump <- compileNimble(pump)
CpumpLaplace <- compileNimble(pumpLaplace, project = pump)
# Calculate MLEs
res <- CpumpLaplace$LaplaceMLE(c(0.1, 0.1))
summ <- CpumpLaplace$summary(res)
}

}
\author{
Wei Zhang, Perry de Valpine
}
